
builtin::Exception: class{
	@message;
	@backtrace;

	initialize: method(message:""){
		@message = message;
		@backtrace = [];
	}

	backtrace: @backtrace;

	message: @message;

	append_backtrace: method(file, line, name){
		if(name){
			@backtrace.push_back(%t"\t%(file)s:%(line)d: in %(name)s"(
				file:file,
				line:line,
				name:name));
		}else{
			@backtrace.push_back(%t"\t%(file)s:%(line)d:"(
				file:file,
				line:line));
		}
	}

	to_s: method{
		return this.class.object_name ~ ": " ~ @message.to_s ~ "\n" ~ @backtrace.each.join("\n");
	}
}

builtin::RuntimeError: class(Exception){}
builtin::IOError: class(Exception){}
builtin::LogicError: class(Exception){}
builtin::BadCastError: class(Exception){}
builtin::InvalidArgumentError: class(Exception){}
builtin::BadYieldError: class(Exception){}
builtin::BadInstanceVariableError: class(Exception){}
builtin::UnsupportedError: class(Exception){}
builtin::BadRedefineError: class(Exception){}
builtin::AssertionFailed: class(Exception){
	initialize: method(message, expr){
		Exception::initialize(%t"'%s':%s"(expr, message));
	}
}
builtin::CompileError: class(Exception){
	initialize: method(message, errors){
		Exception::initialize(%t"%s\n%s"(message, errors.join("\t\n")));
	}		
}		

Enumerable::collect: method(conv){ return this.each.collect(conv); }
Enumerable::map: method(conv){ return this.each.map(conv); }
Enumerable::select: method(pred){ return this.each.select(pred); }
Enumerable::filter: method(pred){ return this.each.filter(pred); }
Enumerable::to_a: method(){ return this.each.to_a; }
Enumerable::join: method(sep:","){ return this.each.join(sep); }
Enumerable::with_index: method(start:0){ return this.each.with_index(start); }
Enumerable::iter_first: method(){ return this.each.iter_first; }
Enumerable::cycle: method(){ return this.each.cycle; }
Enumerable::break_if: method(pred){ return this.each.break_if(pred); }
Enumerable::take: method(times){ return this.each.take(times); }
Enumerable::zip: method(...){ return this.each.zip(...); }
Enumerable::unique: method(){ return this.each.unique; }
Enumerable::unique_if: method(pred){ return this.each.unique_if(pred); }
Enumerable::chain: method(){ return this.each.chain; }

Iterator::to_a: method{
	ret: [];
	this{
		ret.push_back(it); 
	}
	return ret;
}

Iterator::join: method(sep:","){
	ret: StringStream();
	first: true;
	this{
		if(first){
			first = false;
		}else{
			ret.write(sep);
		}
		ret.write(it.to_s);
	}
	return ret.to_s;
}

Iterator::with_index: method(start:0){
	return fiber{		
		this{
			yield start, it;
			++start;
		}
	}
}

Iterator::collect: method(conv){
	return fiber{
		this{
			yield conv(it);
		}
	}
}

Iterator::map: Iterator::collect;

Iterator::select: method(pred){
	return fiber{
		this{
			if(pred(it)){
				yield it;
			}
		}
	}
}

Iterator::filter: Iterator::select;

Iterator::each: method{ 
	return this; 
}


Iterator::break_if: method(pred){
	return fiber{
		this{
			if(pred(it))
				break;
			yield it;
		}
	}
}

Iterator::take: method(times){
	return fiber{
		i: 0;
		this{
			if(i>=times)
				break;
			yield it;
			i++;
		}
	}
}

Iterator::zip: method(...){
	return builtin::zip(this, ...);
}

Iterator::unique: method(){
	return fiber{
		prev: once class{}
		this{
			if(prev!=it){
				yield it;
				prev = it;
			}
		}
	}
}

Iterator::unique_if: method(pred){
	return fiber{
		prev: once class{}
		this{
			if(pred(it, prev)){
				yield it;
				prev = it;
			}
		}
	}
}

builtin::chain: fun(...){
	arg: ...;
	return fiber{
		arg.each_ordered{
			it{
				yield it;
			}
		}
	}
}

Iterator::chain: method(...){
	return builtin::chain(this, ...);
}

Iterator::cycle: method{
	return fiber{
		temp: [];
		this{
			temp.push_back(it);
			yield it;
		}
		
		for(;;){
			temp{
				yield it;
			}
		}
	}
}

Any::p: method{
	println(this.to_s);
	return this;
}

Any::to_s: method{
	return this.object_name;
}

Int::times: method{
	return fiber{
		for(i: 0; i<this; ++i){
			yield i;
		}
	}
}

Null::to_s: method{
	return "null";
}

Null::iter_first: method{
	return null;
}

builtin::range: fun(first, last, step:1){
	if(step==1){
		return fiber{
			while(first<last){
				yield first;
				first++;
			}
		}
	}else{
		return fiber{
			while(first<last){
				yield first;
				first += step;
			}
		}
	}
}

builtin::load: fun(file_name, ...){
	code: compile_file(file_name);
	return code(...);
}

Arguments::each: method{
	return fiber{ 
		this.ordered_args.with_index{ |i, v|
			yield i, v;
		}
		this.named_args{ |i, v|
			yield i, v;
		}
	}
}

Fun::call: method(...){
	return this(...);
}

builtin::open: fun(file_name, mode: "r"){
	ret: null;
	try{
		ret = FileStream(file_name, mode);
	}catch(e){
		ret = null;
	}
	return ret;
}

Mutex::iter_first: method{
	this.lock;
	return this;
}

Mutex::iter_next: method{
	this.unlock;
	return null;
}

Mutex::iter_break: method{
	this.unlock;
	return null;
}

Int::op_add: method(rhs){ return rhs.op_add_r_Int(this); }
Int::op_add_assign: Int::op_add;
Int::op_sub: method(rhs){ return rhs.op_sub_r_Int(this); }
Int::op_sub_assign: Int::op_sub;
Int::op_cat: method(rhs){ return rhs.op_cat_r_Int(this); }
Int::op_cat_assign: Int::op_cat;
Int::op_mul: method(rhs){ return rhs.op_mul_r_Int(this); }
Int::op_mul_assign: Int::op_mul;
Int::op_div: method(rhs){ return rhs.op_div_r_Int(this); }
Int::op_div_assign: Int::op_div;
Int::op_mod: method(rhs){ return rhs.op_mod_r_Int(this); }
Int::op_mod_assign: Int::op_mod;
Int::op_and: method(rhs){ return rhs.op_and_r_Int(this); }
Int::op_and_assign: Int::op_and;
Int::op_or: method(rhs){ return rhs.op_or_r_Int(this); }
Int::op_or_assign: Int::op_or;
Int::op_xor: method(rhs){ return rhs.op_xor_r_Int(this); }
Int::op_xor_assign: Int::op_xor;
Int::op_shr: method(rhs){ return rhs.op_shr_r_Int(this); }
Int::op_shr_assign: Int::op_shr;
Int::op_shl: method(rhs){ return rhs.op_shl_r_Int(this); }
Int::op_shl_assign: Int::op_shl;
Int::op_ushr: method(rhs){ return rhs.op_ushr_r_Int(this); }
Int::op_ushr_assign: Int::op_ushr;
Int::op_eq: method(rhs){ return rhs.op_eq_r_Int(this); }
Int::op_eq_assign: Int::op_eq;
Int::op_lt: method(rhs){ return rhs.op_lt_r_Int(this); }
Int::op_lt_assign: Int::op_lt;

Float::op_add: method(rhs){ return rhs.op_add_r_Float(this); }
Float::op_add_assign: Float::op_add;
Float::op_sub: method(rhs){ return rhs.op_sub_r_Float(this); }
Float::op_sub_assign: Float::op_sub;
Float::op_cat: method(rhs){ return rhs.op_cat_r_Float(this); }
Float::op_cat_assign: Float::op_cat;
Float::op_mul: method(rhs){ return rhs.op_mul_r_Float(this); }
Float::op_mul_assign: Float::op_mul;
Float::op_div: method(rhs){ return rhs.op_div_r_Float(this); }
Float::op_div_assign: Float::op_div;
Float::op_mod: method(rhs){ return rhs.op_mod_r_Float(this); }
Float::op_mod_assign: Float::op_mod;
Float::op_and: method(rhs){ return rhs.op_and_r_Float(this); }
Float::op_and_assign: Float::op_and;
Float::op_or: method(rhs){ return rhs.op_or_r_Float(this); }
Float::op_or_assign: Float::op_or;
Float::op_xor: method(rhs){ return rhs.op_xor_r_Float(this); }
Float::op_xor_assign: Float::op_xor;
Float::op_shr: method(rhs){ return rhs.op_shr_r_Float(this); }
Float::op_shr_assign: Float::op_shr;
Float::op_shl: method(rhs){ return rhs.op_shl_r_Float(this); }
Float::op_shl_assign: Float::op_shl;
Float::op_ushr: method(rhs){ return rhs.op_ushr_r_Float(this); }
Float::op_ushr_assign: Float::op_ushr;
Float::op_eq: method(rhs){ return rhs.op_eq_r_Float(this); }
Float::op_eq_assign: Float::op_eq;
Float::op_lt: method(rhs){ return rhs.op_lt_r_Float(this); }
Float::op_lt_assign: Float::op_lt;

Int::op_pos: method(){ return this; }
Int::op_neg: method(){ return -this; }
Int::op_com: method(){ return ~this; }
Int::op_inc: method(){ return this + 1; }
Int::op_dec: method(){ return this - 1; }

Int::op_add_r_Int: method(lhs){ return lhs + this; }
Int::op_sub_r_Int: method(lhs){ return lhs - this; }
Int::op_mul_r_Int: method(lhs){ return lhs * this; }
Int::op_div_r_Int: method(lhs){ return lhs / this; }
Int::op_mod_r_Int: method(lhs){ return lhs % this; }
Int::op_or_r_Int: method(lhs){ return lhs | this; }
Int::op_and_r_Int: method(lhs){ return lhs & this; }
Int::op_xor_r_Int: method(lhs){ return lhs ^ this; }
Int::op_shr_r_Int: method(lhs){ return lhs >> this; }
Int::op_shl_r_Int: method(lhs){ return lhs << this; }
Int::op_ushr_r_Int: method(lhs){ return lhs >>> this; }
Int::op_eq_r_Int: method(lhs){ return lhs == this; }
Int::op_lt_r_Int: method(lhs){ return lhs < this; }

Int::op_add_r_Float: method(lhs){ return lhs + this; }
Int::op_sub_r_Float: method(lhs){ return lhs - this; }
Int::op_mul_r_Float: method(lhs){ return lhs * this; }
Int::op_div_r_Float: method(lhs){ return lhs / this; }
Int::op_mod_r_Float: method(lhs){ return lhs % this; }
Int::op_eq_r_Float: method(lhs){ return lhs == this; }
Int::op_lt_r_Float: method(lhs){ return lhs < this; }

Float::op_pos: method(){ return this; }
Float::op_neg: method(){ return -this; }
Float::op_inc: method(){ return this + 1; }
Float::op_dec: method(){ return this - 1; }

Float::op_add_r_Int: method(lhs){ return lhs + this; }
Float::op_sub_r_Int: method(lhs){ return lhs - this; }
Float::op_mul_r_Int: method(lhs){ return lhs * this; }
Float::op_div_r_Int: method(lhs){ return lhs / this; }
Float::op_mod_r_Int: method(lhs){ return lhs % this; }
Float::op_eq_r_Int: method(lhs){ return lhs == this; }
Float::op_lt_r_Int: method(lhs){ return lhs < this; }

Float::op_add_r_Float: method(lhs){ return lhs + this; }
Float::op_sub_r_Float: method(lhs){ return lhs - this; }
Float::op_mul_r_Float: method(lhs){ return lhs * this; }
Float::op_div_r_Float: method(lhs){ return lhs / this; }
Float::op_mod_r_Float: method(lhs){ return lhs % this; }
Float::op_eq_r_Float: method(lhs){ return lhs == this; }
Float::op_lt_r_Float: method(lhs){ return lhs < this; }
