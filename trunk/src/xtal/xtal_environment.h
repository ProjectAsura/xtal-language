#ifndef XTAL_ENVIRONMENT_H_INCLUDE_GUARD
#define XTAL_ENVIRONMENT_H_INCLUDE_GUARD

#pragma once

namespace xtal{

class AllocatorLib{
public:
	virtual ~AllocatorLib(){}
	virtual void* malloc(std::size_t size){ return std::malloc(size); }
	virtual void free(void* p, std::size_t size){ std::free(p); }
};

class ChCodeLib{
public:
	virtual ~ChCodeLib(){}

	virtual int_t ch_len(char_t lead){ return 1; }
	virtual int_t ch_len2(const char_t* str){ return ch_len(*str); }
	virtual StringPtr ch_inc(const char_t* data, int_t data_size);
	virtual int_t ch_cmp(const char_t* a, int_t asize, const char_t* b, int_t bsize);
};

class ThreadLib{
public:
	virtual ~ThreadLib(){}

	virtual void* new_thread(){ return 0; }
	virtual void delete_thread(void* thread_object){}
	virtual void start_thread(void* thread_object, void (*callback)(void*), void* data){}
	virtual void join_thread(void* thread_object){}

	virtual void* new_mutex(){ return 0; }
	virtual void delete_mutex(void* mutex_object){}
	virtual void lock_mutex(void* mutex_object){}
	virtual void unlock_mutex(void* mutex_object){}

	virtual void yield(){}
	virtual void sleep(float_t sec){}
};

class StdStreamLib{
public:
	virtual ~StdStreamLib(){}

	virtual void* new_stdin_stream(){ return 0; }
	virtual void delete_stdin_stream(void* stdin_stream_object){}
	virtual uint_t read_stdin_stream(void* stdin_stream_object, void* dest, uint_t size){ return 0; }

	virtual void* new_stdout_stream(){ return 0; }
	virtual void delete_stdout_stream(void* stdout_stream_object){}
	virtual uint_t write_stdout_stream(void* stdout_stream_object, const void* src, uint_t size){ return 0; }

	virtual void* new_stderr_stream(){ return 0; }
	virtual void delete_stderr_stream(void* stderr_stream_object){}
	virtual uint_t write_stderr_stream(void* stderr_stream_object, const void* src, uint_t size){ return 0; }
};

class FilesystemLib{
public:
	virtual ~FilesystemLib(){}

	virtual bool is_directory(const StringPtr& path){ return false; }

	virtual void* new_file_stream(const char_t* path, const char_t* flags){ return 0; }
	virtual void delete_file_stream(void* file_stream_object){}
	virtual uint_t read_file_stream(void* file_stream_object, void* dest, uint_t size){ return 0; }
	virtual uint_t write_file_stream(void* file_stream_object, const void* src, uint_t size){ return 0; }
	virtual void seek_file_stream(void* file_stream_object, uint_t pos){}
	virtual uint_t tell_file_stream(void* file_stream_object){ return 0; }
	virtual bool end_file_stream(void* file_stream_object){ return true; }
	virtual uint_t size_file_stream(void* file_stream_object){ return 0; }
	virtual void flush_file_stream(void* file_stream_object){}

	virtual void* new_entries(const char_t* path){ return 0; }
	virtual void delete_entries(void* entries_object){}
	virtual const char_t* next_entries(void* entries_object){ return 0; }
	virtual void break_entries(void* entries_object){}

};

struct Setting{
	AllocatorLib* allocator_lib;
	ChCodeLib* ch_code_lib;
	ThreadLib* thread_lib;
	StdStreamLib* std_stream_lib;
	FilesystemLib* filesystem_lib;

	Setting();
};

/**
* @brief Xtal実行環境を初期化する。
*/
void initialize(const Setting& setting);

/**
* @brief Xtal実行環境を破棄する。
*/
void uninitialize();

/**
* @brief 現在のカレントのXtal実行環境を取得する。
*/
Environment* environment();

/**
* @brief カレントのXtal実行環境を設定する。
*/
void set_environment(Environment* e);

/////////////////////////////////////////////////////

/**
* @brief ユーザーが登録したメモリアロケート関数を使ってメモリ確保する。
*
*/
void* xmalloc(size_t size);

/**
* @brief ユーザーが登録したメモリデアロケート関数を使ってメモリ解放する。
*
*/
void xfree(void* p, size_t size);

/**
* @brief メモリ確保をスコープに閉じ込めるためのユーティリティクラス
*/
struct XMallocGuard{
	XMallocGuard():p(0){}
	explicit XMallocGuard(uint_t size):p(xmalloc(size)), sz(size){}
	~XMallocGuard(){ xfree(p, sz); }
public:	
	void malloc(size_t size){ xfree(p, sz); p = xmalloc(size); sz = size; }
	void* get(){ return p; }
	void* release(){ void* ret = p; p = 0; return ret; }
	uint_t size(){ return sz; }
private:
	void* p;
	uint_t sz;

	XTAL_DISALLOW_COPY_AND_ASSIGN(XMallocGuard);
};

/////////////////////////////////////////////////////

/**
* @brief ガーベジコレクションを実行する
*
* さほど時間はかからないが、完全にゴミを解放できないガーベジコレクト関数
* 例えば循環参照はこれでは検知できない。
*/
void gc();

/**
* @brief 循環オブジェクトも解放するフルガーベジコレクションを実行する
*
* 時間はかかるが、現在ゴミとなっているものはなるべく全て解放するガーベジコレクト関数
* 循環参照も検知できる。
*/
void full_gc();

/**
* @brief ガーベジコレクションを無効化する
*
* gcやfull_gcの呼び出しを無効化する関数。
* 内部でこれが何回呼び出されたか記憶されており、呼び出した回数enable_gcを呼びないとガーベジコレクションは有効にならない
*/
void disable_gc();

/**
* @brief ガーベジコレクションを有効化する
*
* disable_gcが呼ばれた回数と同じだけ呼び出すとガーベジコレクションが有効になる
*/
void enable_gc();

uint_t alive_object_count();

RefCountingBase* alive_object(uint_t i);

/////////////////////////////////////////////////////

/**
* @brief keyに対応するC++のクラスのクラスオブジェクトを返す。
*/
const ClassPtr& cpp_class(CppClassSymbolData* key);

/**
* @brief keyに対応するC++のクラスのクラスオブジェクトを設定する。
*/
void set_cpp_class(const ClassPtr& cls, CppClassSymbolData* key);

/**
* @brief クラスTに対応するC++のクラスのクラスオブジェクトを返す。
*/
template<class T>
inline const ClassPtr& cpp_class(){
	return cpp_class(&CppClassSymbol<T>::value);
}

/**
* @brief クラスTに対応するC++のクラスのクラスオブジェクトを設定する。
*/
template<class T>
inline void set_cpp_class(const ClassPtr& cls){
	return set_cpp_class(cls, &CppClassSymbol<T>::value);
}

/**
* @brief T形をxtalで扱えるクラスを取得する。
*/
template<class T>
inline const SmartPtr<T>& cpp_singleton(){
	return unchecked_ptr_cast<T>(cpp_class<T>());
}

/**
* @brief T形をxtalで扱えるクラスを生成し、登録する。
*/
template<class T>
inline const SmartPtr<T>& new_cpp_singleton(){
	set_cpp_class<T>(xnew<T>());
	return unchecked_ptr_cast<T>(cpp_class<T>());
}

/////////////////////////////////////////////////////

/**
* @brief クラスのメンバを取り出す。
*/
const AnyPtr& cache_member(const AnyPtr& target_class, const IDPtr& primary_key, const AnyPtr& secondary_key, int_t& accessibility);

/**
* @brief クラスの継承関係を調べる。
*/
bool cache_is(const AnyPtr& target_class, const AnyPtr& klass);

/**
* @brief クラスのコンストラクタがキャッシュされているから調べる。
*/
bool cache_ctor(const AnyPtr& target_class, int_t kind);

/**
* @brief メンバーのキャッシュテーブルに登録されているデータを無効にする。
*/
void invalidate_cache_member();

/**
* @brief 継承関係のキャッシュテーブルに登録されているデータを無効にする。
*/
void invalidate_cache_is();

/**
* @brief クラスのコンストラクタのキャッシュテーブルに登録されているデータを無効にする。
*/
void invalidate_cache_ctor();

/////////////////////////////////////////////////////

/**
* @brief VMachineインスタンスをレンタルする。
*/
VMachinePtr vmachine_take_over();

/**
* @brief VMachineインスタンスを返却する。
*/
void vmachine_take_back(const VMachinePtr& vm);

/////////////////////////////////////////////////////

/**
* @brief builtinシングルトンクラスを返す
*/
const ClassPtr& builtin();

/**
* @brief libオブジェクトを返す
*/
const LibPtr& lib();

/**
* @brief stdinストリームオブジェクトを返す
*/
const StreamPtr& stdin_stream();

/**
* @brief stdoutストリームオブジェクトを返す
*/
const StreamPtr& stdout_stream();

/**
* @brief stderrストリームオブジェクトを返す
*/
const StreamPtr& stderr_stream();

/**
* @brief filesystemシングルトンオブジェクトを返す
*/
const FilesystemPtr& filesystem();

/**
* @brief debugシングルトンオブジェクトを返す
*/
const DebugPtr& debug();

/**
* @brief デバッグ機能を有効にする
* デバッグ機能はデフォルトでは無効になっている。
*/
void enable_debug();

/**
* @brief デバッグ機能を無効にする
*/
void disable_debug();

/**
* @brief 文字列リテラルをインターン済み文字列に変換する
*/
const IDPtr& intern_literal(const char_t* str, IdentifierData* iddata);

/**
* @brief 文字列をインターン済み文字列に変換する
*/
const IDPtr& intern(const char_t* str);

/**
* @brief 文字列をインターン済み文字列に変換する
*/
const IDPtr& intern(const char_t* str, uint_t data_size);

/**
* @brief インターン済み文字列を列挙する
*/
AnyPtr interned_strings();

/**
* @brief 環境をロックする
*/
void xlock();

/**
* @brief 環境をアンロックする
*/
void xunlock();

struct XUnlock{
	XUnlock(int){ xunlock(); }
	~XUnlock(){ xlock(); }
	operator bool() const{ return true; }
private:
	XTAL_DISALLOW_COPY_AND_ASSIGN(XUnlock);
};

void register_thread(Environment*);

void unregister_thread(Environment*);

ThreadLib* thread_lib();
StdStreamLib* std_stream_lib();
FilesystemLib* filesystem_lib();

/**
* @brief VMachinePtrオブジェクトを返す
*
* グローバルなVMachinePtrオブジェクトを返す。
* スレッド毎にこのグローバルVMachinePtrオブジェクトは存在する。
*/
const VMachinePtr& vmachine();

/**
* @brief テキストマップを返す
*/
const MapPtr& text_map();

/**
* @brief 先頭バイトを見て、そのマルチバイト文字が何文字かを調べる。
*
* マイナスの値が返された場合、最低文字数を返す。
* -2の場合、最低2文字以上の文字で、本当の長さは2文字目を読まないと判断できない、という意味となる。
*/
int_t ch_len(char_t lead);

/**
* @brief マルチバイト文字が何文字かを調べる。
*
* int_t ch_len(char_t lead)が呼ばれた後、マイナスの値を返した場合に続けて呼ぶ。
* ch_lenで-2の値を返した後は、strの先には最低2バイト分のデータを格納すること。
*/
int_t ch_len2(const char_t* str);


/**
* @brief 一つ先の文字を返す
*
* 例えば a を渡した場合、b が返る
*/
StringPtr ch_inc(const char_t* data, int_t data_size);

/**
* @brief 文字の大小判定
*
* 負の値 a の文字の方がbの文字より小さい
* 0の値 等しい
* 正の値 bの文字の方がaの文字より小さい
*/
int_t ch_cmp(const char_t* a, uint_t asize, const char_t* b, uint_t bsize);

/**
* @biref 演算子の名前をあらわす文字列の配列を返す
*/
const IDPtr* id_op_list();

StreamPtr open(const StringPtr& file_name, const StringPtr& mode);

#ifndef XTAL_NO_PARSER

/**
* @brief file_nameファイルをコンパイルする。
*
* @param file_name Xtalスクリプトが記述されたファイルの名前
* @return 実行できる関数オブジェクト
* この戻り値をserializeすると、バイトコード形式で保存される。
*/
CodePtr compile_file(const StringPtr& file_name);

/**
* @brief source文字列をコンパイルする。
*
* @param source Xtalスクリプトが記述された文字列
* @return 実行できる関数オブジェクト
* この戻り値をserializeすると、バイトコード形式で保存される。
*/
CodePtr compile(const StringPtr& source);

/**
* @brief file_nameファイルをコンパイルして実行する。
*
* @param file_name Xtalスクリプトが記述されたファイルの名前
* @return スクリプト内でreturnされた値
*/
AnyPtr load(const StringPtr& file_name);

/**
* @brief file_nameファイルをコンパイルしてコンパイル済みソースを保存し、実行する。
*
* @param file_name Xtalスクリプトが記述されたファイルの名前
* @return スクリプト内でreturnされた値
*/
AnyPtr load_and_save(const StringPtr& file_name);

CodePtr source(const char_t* src, int_t size, const char* file);

#endif

CodePtr compiled_source(const void* src, int_t size, const char* file);

}

#endif // XTAL_ENVIRONMENT_H_INCLUDE_GUARD
