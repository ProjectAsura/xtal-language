=関数リテラル=
 fun _[_ ( _[_ _ident_ *,* _ident_ _..._ _]_) _]_ { _stmt_ }

 fun _[_ ( _[_ _ident_ *,* _ident_ _..._ _]_) _]_ _expr_

 | _[_ _ident_ *,* _ident_ _..._ _]_ | _expr_

関数を生成する式は次のように記述します。
{{{
foo: fun(name1, name2){
  return name1 + name2;
}
foo(10, 20).p; // 30が出力される。
}}}

簡易的な記法も存在します。
fun()の後をブロックではなく式を記述します。自動的にこの式の結果を返す関数となります。
{{{
foo: fun(name1, name2) name1 + name2;
}}}

さらに簡易的に、次のように書くことも出来ます。
{{{
foo: |name1, name2| name1 + name2;
}}}

2つの値のうち、大きい方を返す関数maxは次のように書けます。
{{{
max: fun(a, b){
  if(a<b){
    return b;
  }else{
    return a;
  }
}

// または
// max: fun(a, b) a<b ? b : a;

// これでもok
// max: |a, b| a<b ? b : a;
}}}

これを呼び出すには次のようにします。

{{{
max(5, 8); // 8が返る。
}}}

引数を一つも取らない場合、()は省略することも可能です。
{{{
foo: fun{
  "foo!".p;
}
}}}

引数名:値 という書式でデフォルト値の指定が出来ます。
{{{
foo_with_default_value: fun(a:0){
  a.p;
}
}}}

関数foo_with_default_valueは引数aを省略するとデフォルトの0がaに入る関数となります。

デフォルト引数を付加した引数は自動的に名前付き引数となります。
呼び出すときに
{{{
 foo_with_default_value(a:50);
}}}
というように、引数名:値という書式で指定します。

可変引数もサポートしています。
関数の引数の最後を...とすると可変引数を取る関数定義となります。
{{{
 foo: fun(a, ...){
   println("a ", a);
   println("0 ", ...[0]); // 関数中の ... は、現在の関数の可変引数オブジェクトを表しています。
   println("named ", ...["named"]);
   
   bar(...); //bar関数に可変引数部分全てを渡す
 }
 
 foo(5, 10, 20, named:"test"); 
 // a 5
 // 0 10
 // named test
 // と表示される
}}}

可変引数オブジェクトはArgumentsクラスのインスタンスであり、Argumentsクラスのメソッドを呼ぶことが出来ます。

{{{
fun(...){
  // 順番指定引数を全てプリントする
  ....each_ordered_arg{
    it.p;
  }
}
}}}

==dofun式==
定義して即実行する関数です。
次とまったく同じ意味です。
{{{
(fun{
  return 10;
})();
}}}

==メソッド生成式==
メソッドを生成する式の書式は、関数生成式のfunの部分をmethodに変えるだけです。
{{{
m: method(name1, name2){
  return name1 + name2;
} 

m(10, 20).p; // 30が出力される。
}}}

funで関数を生成することの違いは、擬似変数thisの扱われ方だけです。
funの場合thisは、その外側のスコープのthisがそのまま使われます。
しかしmethodの場合、thisが何を指すかは、ダイナミックスコープで決まります。

methodが obj.foo() 形式で呼び出されたとき、thisはobjとなります。
そうでなく、ただ foo() と呼ばれたときは、その呼び出した関数のthisがそのままthisとして使われます。

{{{
Foo: class{
  
  return_fun: method(){
    return fun(){
      this.boo();
    }
  }

  return_method: method(){
    return method(){
      this.boo();
    }
  }

  boo: method(){
    "boo!".p;
  }
}

// Fooクラスをインスタンス化
foo: Foo();

// return_funメソッドが返す関数をfに入れる
f: foo.return_fun();

// ここでfを呼び出すと boo! と表示される。
f();

// このように、funは関数が生成されたときのthisを記憶しているので、
// methodから返された場合でも、thisが正しくオブジェクトを指している訳です。


// methodを返す場合どうなるか
// return_methodメソッドが返す関数をmに入れる
m: foo.return_method();

// ここでfを呼び出すと例外が送出される。
// なぜなら、methodは関数が作られた場所のthisを記憶せず、呼び出し元のthisを使用するため。
// トップレベルではthisはnullである。
f();
}}}

==ファイバー生成式==
ファイバーを生成する式の書式は、関数生成式のfunの部分をfiberに変えるだけです。
ファイバーはyieldを使うことで、実行を一時中断して、また途中から再実行が出来る特殊な関数です。

{{{
fib: fiber(){
  1.p;
  yield;
  2.p;
}
 
fib(); //=> 1
fib(); //=> 2
}}}

yieldで値を返すことも出来ます。

{{{
fib: fiber(){
  yield 10;
  yield 20;
  yield 30;
}

fib().p; //=> 10
fib().p; //=> 20
fib().p; //=> 30
}}}

fiberのthisの扱われ方はfunと同じです。

また、fiberはiteratorオブジェクトとしても扱えます。
つまり、ブロック文の適用が可能です。

{{{
fib{ |val|
  val.p;
}
}}}